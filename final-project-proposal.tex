\documentclass[titlepage,12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{enumitem}
\usepackage[shortlabels]{enumerate}
\usepackage{titlesec}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage[makeroom]{cancel}

\title{Final Project Proposal}
\author{Sumner Evans, Robbie Merillat, Sam Sartor}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

VR Technology has been developing rapidly in the 21st century. Current solutions
such as Unity attempt to use old programming languages and paradigms to
implement VR environments and thus limit developers' abilities to create new and
unique environments. With every cutting edge technology, new paradigms and
design patterns must be invented. This project intends to explore and implement
these paradigms and design patterns.

\section{Objectives}

The goal of this project is to experiment with a variety of paradigms and design
patterns to see which work best for implementing VR environments. To do this, we
will implement four different VR environments where users can move around and
interact with a variety of virtual objects. Each team member will build one
environment individually and the fourth will be built by the whole team and will
connect the individually-built environments.

\subsection{Environments and Interactions}
The following sections describe the concepts for our four environments and the
interactions that can occur in each environment.


\subsubsection{Sam --- Workbench}
The goal of this environment is to find a general pattern for VR element design
that can apply to both diegetic (semi-realistic) and spacial (purely abstract)
items. Specifically, it includes logic for moving, placing, snapping, and
recombining arbitrary VR elements. These elements are split into 2 categories.
Some are purely abstract user interface items (spacial), others are blocks that
appear more concrete (diegetic). The user has the ability to recombine blocks
into moving objects such as miniature vehicles. More interestingly, the user can
recombine interface elements into static control ``devices'' for these objects.
For example, the user could attach 4 rocket engines together, and control it by
combining the 4 thrust controls into a crude joystick.

\subsubsection{Sumner --- Snowflakes}
Snowflakes will be a winter-themed environment where users can create their own
structures by manipulating snow blocks. The environment will have ``snow'' on
the ground and winter themed items in the environment such as snowmen. The user
will be able to create new snow blocks by pointing both controllers at the
ground and pulling both of the triggers. This action will create a snow block
being held between the users hands. When the user releases the triggers, the
snow block will fall in a physically-accurate manner with collision detection.

\subsubsection{Robbie --- Let's Get Physical}
This project provides a physically ``real'' environment.  That is an environment
that applies some of the fundamental laws of physics as we know them. Simple
gravitational pull, acceleration, and collisions which in turn includes
momentum. To achieve this, the Rust \texttt{nphysics3d} library is used to
provide physics utility functions to the program.  Various objects will be
placed around the environment that can be picked up, thrown, dropped, and/or
interacted with in other ways. One example of such interactions would be
shooting a bow and arrow.

\subsubsection{Team --- VRsh}
This environment will be a user-customizable environment where users can:
\begin{enumerate}
    \item Navigate to other environments using a ``program picker''.
    \item Persist the state in other environments using an intuitive UI
        specialized for VR.
    \item Customize the environment state using design motifs that are
        specialized for VR.
\end{enumerate}

\section{Proposed Implementation}
\begin{itemize}
    \item Programs do not themselves store state. They receive state from VRsh
        and then modify it.
    \item Programs register their default state with VRsh?
    \item Creating a new copy of a default environment is done by grabbing the
        environment from the program picker.
    \item VRsh stores all environment state information and when the user
        ``reopens'' a state, VRsh passes that state to the application.
\end{itemize}

\section{Plan of Action}

This project will have four main stages that correlate with the due dates for
the individual assignments and the final project milestones.

\begin{enumerate}[leftmargin=*]
    \item [10/18] \textbf{Individual Assignments} --- Demo the individual
        environments
    \item [11/03] \textbf{Milestone I} --- Building the VRsh environment
    \item [11/17] \textbf{Milestone II} --- Integrating the VRsh and individual
        environments
    \item [12/08] \textbf{Final Code Submission} --- Final touches to the VRsh
        environment.
\end{enumerate}

In addition to the above code submissions, we will also produce a final report
along with the Final Code Submission describing the work that we did and the
lessons we learned while implementing the project.

\subsection{C-MAPP Event Readiness}
Our goal is to have this project ready for the C-MAPP event in January. To do
this, we must have a finished product and report by the end of this semester.

\section{References and Dependencies}

Because of the performance requirements and complexity of virtual reality
software, we decided to use the Rust programming language for all the projects
in this independent study.

Our individual and final projects will all be built using our own shared,
open-source library called \texttt{flight}, which will be continually updated to
reflect what we learn while developing these projects. As of writing,
\texttt{flight} incorporates our own VR hardware interface, several custom
rendering environments, mesh manipulation tools, and a few asset loading
utilities.

Although most of the planned features of our shell can be implemented using the
Rust standard libraries, there are several other tools that we will be depending
on.  The most notable are \texttt{gfx} (a GPU graphics wrapper),
\texttt{nalgebra} (vector and matrix math),\ \texttt{ncollide} (geometric
operations such as collisions and intersections), \texttt{nphysics} (physics
engine), OpenVR (Valve's VR hardware SDK), image (raster image loader), and
futures (asynchronous events). With the exception of OpenVR, all these libraries
can be found on \texttt{crates.io}.

\end{document}
