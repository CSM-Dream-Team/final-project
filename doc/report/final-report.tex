% vim: spell spelllang=en_us
\documentclass[conference,12pt]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{biblatex}
\usepackage{amsmath}
\usepackage{minted}
\usepackage[inline]{enumitem}
\usepackage{amsthm}
\usepackage{mdframed}

\MakeOuterQuote{"}

\addbibresource{references.bib}

\setminted{autogobble,python3,mathescape,fontsize=\footnotesize}
\newcommand\tab[1][.5in]{\hspace*{#1}}
\newcommand\name{VRsh}
\newtheorem{definition}{Definition}

\title{Final Project Report}
\author{%
    \IEEEauthorblockN{%
        Jonathan Sumner Evans\IEEEauthorrefmark{1},
        Robinson Merillat\IEEEauthorrefmark{2}, and
        Sam Sartor\IEEEauthorrefmark{3}
    }
    \IEEEauthorblockA{%
        Department of Computer Science,
        Colorado School of Mines\\
        Golden, Colorado\\
        Email:
            \IEEEauthorrefmark{1}jonathanevans@mines.edu,
            \IEEEauthorrefmark{2}rdmerillat@mines.edu,
            \IEEEauthorrefmark{3}ssartor@mines.edu
    }
}

\begin{document}
\maketitle
\begin{abstract}
    Virtual Reality (VR) Technology has been developing rapidly over the past
    decade. Current solutions such as Unity attempt to use old programming
    languages and even older paradigms to implement VR applications and thus, limit
    developers' abilities to create new and unique environments.  With every
    cutting edge technology, new paradigms and design patterns must be invented.
    In this paper, we discuss a deferred immediate mode (DIM) application
    architecture suitable for implementing large virtual reality applications.
    We present a UI library which utilizes this architecture and a few case
    studies of this library in use.
\end{abstract}

\section{Introduction}\label{sec:introduction}
The Virtual Reality (VR) market is growing rapidly. The International Data
Corporation (IDC) projects that revenues for the combined Augmented Reality (AR)
and Virtual Reality markets will grow from \$5.2 billion in 2016 to more than
\$162 billion in 2020~\cite{IDC:2016:VR-industry}. This flourishing new industry
has created an exciting new field of Software Engineering with great potential
for revolutionary new design paradigms and program architectures.

Most current frameworks and libraries attempt to apply old design paradigms and
program architectures to virtual reality. While these paradigms and
architectures are well-suited for 2D user interfaces and rendering 3D
environments to a flat screen, they are not designed with VR in mind. Although
endeavors to adapt these old patterns to VR have been successful, they are
restrictive in both the code architecture and way of thinking. Grace Hopper 
loved to say "The most damaging phrase in the language is: `It's always been 
done that way.'"\cite{Hopper:1987:quote} This quote promotes new ways of 
thinking. Utilizing outdated architectures hinders the exploration
and the potential for new design paradigms and program architectures.

Our goal is to find a system that provides a modern, fast, and practical
approach to virtual reality development. Specifically, we require that this
system meets the following criteria.

\subsection{Performant}\label{sec:performant}
Traditionally, animation is done around 60 frames per second.  This is due to the 
wave of monitors and televisions that ran at 60Hz and had a refresh rate of 
60 frames per second (fps).  This is fine when looking at a screen from a distance, 
however it has been found that in order to appear believable and prevent 
disorientation, a virtual reality program must run with at least 90 fps. 
In fact many studies have shown that when VR is run with lower frame rates
users experience headaches and nausea faster than when at high frame rates
\cite{irisVR}. As VR headsets run two mini monitors concurrently, the effective 
required frame rate is 180fps.  Achieving this frame rate is resource intensive 
and requires highly efficient and optimized code. Additionally, multi-threading 
is imperative so that long-running processes can occur without blocking the user
interface. This is unlike a traditional desktop user interface where blocking
the UI process for a second does not have a major affect on the usability of the
program. These factors require a VR framework that is highly performant and
multi-threadable.

\subsection{Natural}\label{sec:natural}
A \textit{natural user interface} is an interface that can be used without the
need for a controller~\cite{Wimmers:2015:VR:Natural-UI}. Although current VR
systems utilize hand-held controllers, they emulate this goal much better than
desktop, mobile, and web applications. For our discussion of these natural user
interfaces, we define the following terms.

\begin{definition}\label{def:planar-ui}
    A {\normalfont\text{planar UI}} is a user interface where components are
    organized along a 2D surface.
\end{definition}

\begin{definition}\label{def:spacial-ui}
    A {\normalfont\text{spacial UI}} is a user interface where components are
    organized within a 3D space.
\end{definition}

Both planar and spacial user interfaces are effective in virtual reality
applications. This cannot be said of applications that use traditional
human-interface devices such as mice and keyboards. Because virtual reality
environments are inherently 3D, they make spacial UI convenient and practical
for the first time. Thus, the ability to create spacial UI rather than merely to
planar UI is a high priority.

\subsection{Flexible}\label{sec:flexible}
Computer software is used to solve a variety of unique problems which in turn
require a variety of user interface solutions. Thus, a good user interface
toolkit must be general enough to accommodate the goals of the developers
writing the software. Most importantly, such a toolkit must not be opinionated
about which types of application should be created with it. The desktop, mobile,
and web application fields already have general purpose user interface toolkits
(e.g.\ HTML and GTK). We need a UI library for VR which is equally
general-purpose.

\subsection{Modular}\label{sec:modular}
A direct result of flexibility is modularity---a flexible architecture cannot be
a monolith. Many current VR libraries include features such as pathfinding and
character rigging which must be included even if they are not used. This is not
modular and most non-entertainment software does not require any of these
features.

From a software engineering standpoint, a good UI library must allow the
programmer to integrate any number of components, but these components should
be add-ons, not dependencies. Additionally, these components should be
compartmentalized and not interfere with one another. This library design
promotes good software engineering practices including the UNIX philosophy ("do
one thing and do it well") and the open/closed principle ("software entities
should be open for extension but closed to modification").

We need a framework that has a minimal feature set baked in while still allowing
extensibility via the addition of self-contained modules.

\begin{center}***\end{center}

Given these criteria, we evaluate current program architectures and UI libraries
including Unity, entity component systems, React-like architectures, and event
tree architectures in Section~\ref{sec:evolution}. We also describe how these
architectures influenced our deferred immediate mode architecture which we
formally present in Section~\ref{sec:dim}. In Section~\ref{sec:flight} we
describe Flight---an implementation of a VR UI library using the deferred
immediate mode architecture. Then we present three case studies of Flight and
the deferred immediate mode architecture in use in real applications in
Section~\ref{sec:case-studies} and conclude in Section~\ref{sec:conclusion}.

\section{Evolution of Deferred Immediate Mode}\label{sec:evolution}
% TODO: Give brief overview of our "adventures in VR library design"
We researched many current VR software architectures to find one which suited
our needs. All of them had many advantages but also many disadvantages. In this
section we describe a variety of libraries and evaluate their ability to
accomplish our goals as described in the previous section.

\subsection{Unity}\label{sec:unity}
Unity is a game engine which was designed to allow programmers to easily create
games and has many features which make this process effortless. Unity has been
used to create many successful, award-winning VR games and applications
including SUPERHOT~\cite{UploadVR:SUPERHOT} and
TiltBrush~\cite{Unity:TiltBrush}. The Unity ecosystem is growing rapidly and has
become the de facto standard for building VR applications. For example, Google
released a TiltBrush toolkit on GitHub under the Apache 2.0
library~\cite{Google:TiltBrush}.

However, Unity's UI system was designed for building 2D UIs and has been adapted
for making 3D UIs. Although these adaptations have been successful, we wanted to
explore systems which have 3D UI elements as first class citizens.

\subsection{A-Frame}\label{sec:aframe}

A-Frame is a virtual reality engine created by Mozilla for the web. Scenes are
built using declarative HTML, and evaluated as an entity component system (ECS).
Unlike traditional object-oriented programming, where new object types generally
inherit functionality from a single parent, an ECS creates objects through
composition. This works very well in a declarative environment, since an entity
can be declared into existence by simply listing a set of components (e.g.\
color, shape, movement, interactivity).
\cite{Mozilla-Hacks:2016:Building-A-Frame}. In addition, building VR apps using
HTML has the distinct advantage of leveraging proven web UI frameworks such as
Facebook's React library \cite{Ngo:2017:AFrame:React}.

React and A-Frame are very effective solutions to the problem of VR on the web,
however both are still fundamentally reliant on the document object model (DOM).
This constrains the performance and generality of virtual reality applications.
If the DOM is entirely abstracted away, then there is no reason to build on it
in the first place. VR can be attacked at a much lower level using desktop VR
frameworks and ported to the web using technologies such as webassembly (WASM).

% \subsection{Entity Component Systems}\label{sec:ecs}

% Entity component systems are just as applicable to desktop VR as to web VR. In
% fact, one of our first attempts ...

% \subsection{Event Tree}\label{sec:event-tree}

% However, this approach has a fatal flaw. Most user interactions in a virtual
% reality environment require global information, that is ..

\section{Deferred Immediate Mode}\label{sec:dim}
% TODO: describe general ideals of our architecture (programming language and
% implementation agnostic)
% TODO: mention how our deferred immediate mode program architecture builds on
% and combines concepts from many previous architectures

\subsection{Deferred}
% TODO: describe why this is cool

\subsection{Immediate Mode}
% TODO: describe why this is cool

\section{Flight}\label{sec:flight}
% TODO: this section should describe the implementation of DIM (or whatever we
% call it)
Flight is our implementation of a VR UI library using the DIM architecture. It
is written in Rust and is designed to be highly modular. It uses Rust
\texttt{FnOnce} closures to implement the deferred aspect of the DIM
architecture and resolves state using a \textit{guru} system.

\subsection{Language}
% TODO: why Rust? Type system.
We chose to implement Flight in Rust for a few reasons.

\subsubsection{Performance}
As mentioned in Section~\ref{sec:performant}, virtual reality requires a high
frame rate.
% TODO: ...

\subsubsection{Type System}
% TODO: ...

% TODO: more stuff here

\subsection{Dependencies}
The Rust dependency manager, Cargo, allows programmers to easily include
third-party libraries from \url{https://crates.io}. To avoid duplicating work
by other programmers, we utilized a few external libraries for Flight. The main
dependencies are listed below.
\begin{itemize}
    \item \textbf{\texttt{WebVR}}: an OpenVR wrapper built by Mozilla for the
        Servo browser.
    \item \textbf{\texttt{nalgebra}}: library for geometric/volumetric
        operations and queries.
    \item \textbf{\texttt{gfx}}: % TODO:
    % TODO: more dependencies?
\end{itemize}

\subsection{Modular}
% TODO:

\subsection{Deferred}
% TODO: describe how we use FnOnces

\subsection{Immediate Mode}
% TODO: describe how we did this (update function)

\subsection{Gurus} % TODO: maybe lump this in with something else?
% TODO: describe how the gurus help resolve things

% TODO: add subsubsections about the various gurus?

\section{Case Studies}\label{sec:case-studies}
% TODO: Explain that we were creating these applications for a VR independent
% study.

\subsection{<TODO: interactivity>}

\subsection{Let's Get Physical and Snowflakes --- Physics}
% TODO: Describe how physics, spawning, etc. works in Immediate Mode & Physics
% guru

\subsection{{\name} --- Global User Interface}
% TODO: Describe how we are using it to make the torus thing

\section{Conclusion}\label{sec:conclusion}
% TODO: Conclude (duh)

{\printbibliography}

\end{document}
