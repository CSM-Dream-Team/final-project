% vim: spell spelllang=en_us
\documentclass[conference,12pt]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{biblatex}
\usepackage{amsmath}
\usepackage{minted}
\usepackage[inline]{enumitem}
\usepackage{amsthm}
\usepackage{mdframed}

\MakeOuterQuote{"}

\addbibresource{references.bib}

\setminted{autogobble,python3,mathescape,frame=lines,framesep=2mm,fontsize=\footnotesize,escapeinside=~~}
\newcommand\tab[1][.5in]{\hspace*{#1}}
\newcommand\name{VRsh}
\newtheorem{definition}{Definition}

\title{Final Project Report}
\author{%
    \IEEEauthorblockN{%
        Jonathan Sumner Evans\IEEEauthorrefmark{1},
        Robinson Merillat\IEEEauthorrefmark{2}, and
        Sam Sartor\IEEEauthorrefmark{3}
    }
    \IEEEauthorblockA{%
        Department of Computer Science,
        Colorado School of Mines\\
        Golden, Colorado\\
        Email:
            \IEEEauthorrefmark{1}jonathanevans@mines.edu,
            \IEEEauthorrefmark{2}rdmerillat@mines.edu,
            \IEEEauthorrefmark{3}ssartor@mines.edu
    }
}

\begin{document}
\maketitle
\begin{abstract}
    Virtual Reality (VR) Technology has been developing rapidly over the past
    decade. Current solutions such as Unity attempt to use old programming
    languages and even older paradigms to implement VR applications and thus, limit
    developers' abilities to create new and unique environments.  With every
    cutting edge technology, new paradigms and design patterns must be invented.
    In this paper, we discuss a deferred immediate mode (DIM) application
    architecture suitable for implementing large virtual reality applications.
    We present a UI library which utilizes this architecture and a few case
    studies of this library in use.
\end{abstract}

\section{Introduction}\label{sec:introduction}
The Virtual Reality (VR) market is growing rapidly. The International Data
Corporation (IDC) projects that revenues for the combined Augmented Reality (AR)
and Virtual Reality markets will grow from \$5.2 billion in 2016 to more than
\$162 billion in 2020~\cite{IDC:2016:VR-industry}. This flourishing new industry
has created an exciting new field of Software Engineering with great potential
for revolutionary new design paradigms and program architectures.

Most current frameworks and libraries attempt to apply old design paradigms and
program architectures to virtual reality. While these paradigms and
architectures are well-suited for 2D user interfaces and rendering 3D
environments to a flat screen, they are not designed with VR in mind. Although
endeavors to adapt these old patterns to VR have been successful, they are
restrictive in both the code architecture and way of thinking. Grace Hopper
loved to say "The most damaging phrase in the language is: `It's always been
done that way'"~\cite{Hopper:1987:quote}. This quote promotes new ways of
thinking. Utilizing outdated architectures hinders the exploration and the
potential for new design paradigms and program architectures.

Our goal is to find a system that provides a modern, fast, and practical
approach to virtual reality development. Specifically, we require that this
system meets the following criteria.

\subsection{Performant}\label{sec:performant}
Traditionally, animation is done around 60 frames per second.  This is due to the
wave of monitors and televisions that ran at 60Hz and had a refresh rate of
60 frames per second (fps).  This is fine when looking at a screen from a distance,
however it has been found that in order to appear believable and prevent
disorientation, a virtual reality program must run with at least 90 fps.
In fact many studies have shown that when VR is run with lower frame rates
users experience headaches and nausea faster than when at high frame rates
\cite{irisVR}. As VR headsets run two mini monitors concurrently, the effective
required frame rate is 180fps.  Achieving this frame rate is resource intensive
and requires highly efficient and optimized code. Additionally, multi-threading
is imperative so that long-running processes can occur without blocking the user
interface. This is unlike a traditional desktop user interface where blocking
the UI process for a second does not have a major affect on the usability of the
program. These factors require a VR framework that is highly performant and
multi-threadable.

\subsection{Natural}\label{sec:natural}
A \textit{natural user interface} is an interface that can be used without the
need for a controller~\cite{Wimmers:2015:VR:Natural-UI}. Although current VR
systems utilize hand-held controllers, they emulate this goal much better than
desktop, mobile, and web applications. For our discussion of these natural user
interfaces, we define the following terms.

\begin{definition}\label{def:planar-ui}
    A {\normalfont\text{planar UI}} is a user interface where components are
    organized along a 2D surface.
\end{definition}

\begin{definition}\label{def:spacial-ui}
    A {\normalfont\text{spacial UI}} is a user interface where components are
    organized within a 3D space.
\end{definition}

Both planar and spacial user interfaces are effective in virtual reality
applications. This cannot be said of applications that use traditional
human-interface devices such as mice and keyboards. Because virtual reality
environments are inherently 3D, they make spacial UI convenient and practical
for the first time. Thus, the ability to create spacial UI rather than merely to
planar UI is a high priority.

\subsection{Flexible}\label{sec:flexible}
Computer software is used to solve a variety of unique problems which in turn
require a variety of user interface solutions. Thus, a good user interface
toolkit must be general enough to accommodate the goals of the developers
writing the software. Most importantly, such a toolkit must not be opinionated
about which types of application should be created with it. The desktop, mobile,
and web application fields already have general purpose user interface toolkits
(e.g.\ HTML and GTK). We need a UI library for VR which is equally
general-purpose.

\subsection{Modular}\label{sec:modular}
A direct result of flexibility is modularity---a flexible architecture cannot be
a monolith. Many current VR libraries include features such as pathfinding and
character rigging which must be included even if they are not used. This is not
modular and most non-entertainment software does not require any of these
features.

From a software engineering standpoint, a good UI library must allow the
programmer to integrate any number of components, but these components should
be add-ons, not dependencies. Additionally, these components should be
compartmentalized and not interfere with one another. This library design
promotes good software engineering practices including the UNIX philosophy ("do
one thing and do it well") and the open/closed principle ("software entities
should be open for extension but closed to modification").

We need a framework that has a minimal feature set baked in while still allowing
extensibility via the addition of self-contained modules.

\begin{center}***\end{center}

Given these criteria, we evaluate current program architectures and UI libraries
in Section~\ref{sec:existing_tools}. We also describe how these architectures
influenced our deferred immediate mode architecture which we formally present in
Section~\ref{sec:dim}. In Section~\ref{sec:flight} we describe Flight---an
implementation of a VR UI library using the deferred immediate mode
architecture. Then we present three case studies of Flight and the deferred
immediate mode architecture in use in real applications in
Section~\ref{sec:case-studies} and conclude in Section~\ref{sec:conclusion}.

\section{Existing Toolkits}\label{sec:existing_tools}
% TODO: Give brief overview of our "adventures in VR library design"
We researched many current VR software architectures to find one which suited
our needs. In this section we describe a variety of libraries and evaluate their
ability to accomplish our goals as described in the previous section.

\subsection{Unity}\label{sec:unity}
Unity is a game engine which was designed to allow programmers to easily create
games and has many features which make this process effortless. Unity has been
used to create many successful, award-winning VR games and applications
including SUPERHOT~\cite{UploadVR:SUPERHOT} and
TiltBrush~\cite{Unity:TiltBrush}. The Unity ecosystem is growing rapidly and has
become the de facto standard for building VR applications. For example, Google
released a TiltBrush toolkit on GitHub under the Apache 2.0
library~\cite{Google:TiltBrush}.

However, Unity's UI system was designed for building 2D UIs and has been adapted
for making 3D UIs. Although these adaptations have been successful, we wanted to
explore systems which have 3D UI elements as first class citizens.

\subsection{A-Frame}\label{sec:aframe}

A-Frame is a virtual reality engine created by Mozilla for the web. Scenes are
built using declarative HTML, and evaluated as an entity component system (ECS).
Unlike traditional object-oriented programming, where new object types generally
inherit functionality from a single parent, an ECS creates objects through
composition. This works very well in a declarative environment, since an entity
can be declared into existence by simply listing a set of components (e.g.\
color, shape, movement, interactivity).
\cite{Mozilla-Hacks:2016:Building-A-Frame}. In addition, building VR apps using
HTML has the distinct advantage of leveraging proven web UI frameworks such as
Facebook's React library \cite{Ngo:2017:AFrame:React}.

React and A-Frame are very effective solutions to the problem of VR on the web,
however both are still fundamentally reliant on the document object model (DOM).
This constrains the performance and generality of virtual reality applications.
If the DOM is entirely abstracted away, then there is no reason to build on it
in the first place. VR can be attacked at a much lower level using desktop VR
frameworks and ported to the web using technologies such as webassembly (WASM).

% \subsection{Entity Component Systems}\label{sec:ecs}

% Entity component systems are just as applicable to desktop VR as to web VR. In
% fact, one of our first attempts ...

% \subsection{Event Tree}\label{sec:event-tree}

% However, this approach has a fatal flaw. Most user interactions in a virtual
% reality environment require global information, that is ..

\section{Deferred Immediate Mode}\label{sec:dim}

After analyzing the those libraries we realized that none of them fully fit our
needs. Thus, we decided to create our own architecture which achieves all of the
goals outlined in Section~\ref{sec:introduction}. It takes an exiting UI
architecture (immediate mode) and introduces a deferred aspect which allows us
to solve the incomplete information problem described below.

\subsection{Immediate Mode}
% TODO: describe why this is cool
All of the libraries and frameworks we discussed in Section~\ref{sec:existing_tools}
use a \textit{retained mode architecture}. Retained mode architectures are
declarative. In the context of user interfaces, this means that the entire user
interface is defined and stored in memory. For each each frame, the graphics
library draws the entire scene from memory. The entire scene is stored in memory
between frames and modification of the scene is done by modifying the in-memory
representation of the scene~\cite{Microsoft:Retained-vs-Immediate}.

Retained mode presents some problems with synchronization across user interface
trees. For example, many applications have a stored state such as a list of
items table. However, there may be elements external to the table which modify
the list of items. This causes a problem of cross mutation. One common way of
fixing this problem in old applications was to add a function call to refresh
the table when the button was clicked. This has major scalability problems when
the elements which are change by a single button form a massive dependency tree.
Additionally, if a programmer misses one refresh call, it can cause the state in
part of the application to become stale.

Currently, one of the popular ways of handling this issue is using Flux, the
underlying architecture of Redux. This model forces state to be stored in a
single global store. Data is sent from this store down the entire UI tree, and
messages which modify the state are propagated upwards through the tree. This
model ensures that there is one source of truth---the common data store---and
that if one component sends a message which modifies that central state, then
the entire UI tree can update accordingly.

% FUTURE: like Wellford's for immediate mode
An alternative way of tackling this problem is using \textit{immediate mode}.
In this architecture, the UI is defined procedurally for each frame. The
graphics library does not store the scene in memory, rather any state that is
necessary to create the scene is stored by the application
itself~\cite{Microsoft:Retained-vs-Immediate}. Immediate mode prevents the
problem of stale state and cross mutation by recomputing the entire UI scene
every frame. In an immediate mode architecture, a programmer defines that a UI
element exists on each frame, and if they want to remove a UI element, they
simply do not call the function to create an element.

The major drawback of immediate mode is that there is no guarantee that another
element will be created later that will interfere with the current element's
state. We call this problem the incomplete information problem. An example of
this problem would be an element in a virtual environment whose color depends on
whether or not the user is pointing at it. It is easy to detect whether or not
the controller is pointed at the element. It is impossible to guarantee that
another component will no be added to the scene which will obstruct the
controller's view of the first element.

In other words, there are some questions about the state of the system which
cannot be answered until all UI elements have "reported" their state.  To solve
this incomplete information problem, we added a new aspect to immediate mode:
deferability described in the next section.

\subsection{Deferred}
retained mode -> does not have the incomplete data problem, has synchronization
problem
immediate mode -> incomplete data problem, not synchronization problem
deferred immediate mode -> keeps lack of synchronization problem form immediate
mode, but adds synchronization by deferring.
% TODO: describe why this is cool

\section{Flight}\label{sec:flight}
% TODO: this section should describe the implementation of DIM (or whatever we
% call it)
Flight is our implementation of a VR UI library and the DIM architecture using
the Rust programming language. Flight is designed from the ground up to be
performant, general, and modular.

\subsection{Language}
% TODO: why Rust? Type system.
We chose to implement Flight in Rust for a few reasons.

\subsubsection{Performance}
As mentioned in Section~\ref{sec:performant}, virtual reality requires a high
frame rate.
% TODO: ...

\subsection{Pattern}

Many DIM functions in flight-ui adhere to the following pattern:

\begin{minted}{rust}
fn dim_function<'partial>(
    // mutates the state of self
    &'partial mut self,
    // depends on some other object
    other: &mut Component
)
    // defer until other is resolved
    -> impl FnOnce(&ComponentOutput)
    // outputs is available once resolved
    -> MyOutput + 'partial
{
    // another component or guru is queried
    let unresolved = self.query(other);
    // deffer further computation
    move |response| {
        // query result is now available
        // return own result
        unresolved(response)
    }
}
\end{minted}

Below is this pattern written more abstractly.

\begin{minted}{text}
define dim_function(queriable):
    query ~$\leftarrow$~ queriable.query()
    yeild until query
    return query.output()
\end{minted}

\subsubsection{Type System}
% TODO: ...

% TODO: more stuff here

\subsection{Dependencies}
The Rust dependency manager, Cargo, allows programmers to easily include
third-party libraries from \url{https://crates.io}. To avoid duplicating work
by other programmers, we utilized a few external libraries for Flight. The main
dependencies are listed below.
\begin{itemize}
    \item \textbf{\texttt{rust-webvr}}: OpenVR wrapper used by the Servo browser
    \item \textbf{\texttt{nalgebra}}: linear primitives, transformations, and operations
    \item \textbf{\texttt{ncollide}}: geometric operations and queries
    \item \textbf{\texttt{nphysics}}: a simple rigid body physics engine
    \item \textbf{\texttt{gfx}}: a powerful, type-safe OpenGL/DX11/Vulkan wrapper
\end{itemize}

\subsection{Modular}
% TODO:

\subsection{Deferred}
% TODO: describe how we use FnOnces

\subsection{Immediate Mode}
% TODO: describe how we did this (update function)

\subsection{Gurus} % TODO: maybe lump this in with something else?
% TODO: describe how the gurus help resolve things

% TODO: add subsubsections about the various gurus?

\section{Case Studies}\label{sec:case-studies}
% TODO: Explain that we were creating these applications for a VR independent
% study.

\subsection{<TODO: interactivity>}

\subsection{Let's Get Physical and Snowflakes --- Physics}
% TODO: Describe how physics, spawning, etc. works in Immediate Mode & Physics
% guru

\subsection{{\name} --- Global User Interface}
% TODO: Describe how we are using it to make the torus thing

\section{Conclusion}\label{sec:conclusion}
% TODO: Conclude (duh)

{\printbibliography}

\end{document}
